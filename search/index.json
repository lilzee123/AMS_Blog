[{"content":"1. DDPM 前向扩散：对一张图片不断加入噪声（正态分布），产生一系列噪声数据。\n去噪过程：训练一个噪声predicter，预测每一个噪声图片的噪声。\nDiffusion的成功：N次迭代？\n噪声predicter：输入为噪声图片，时间步t，text向量（Text-to-Image）\n评价指标：\nFID：Frechet distance between the two Gaussians，评价图片逼真程度\nCLIP Score：评价Text-to-Image的好坏\nStable Diffusion（常用框架）：\nDecoder （1）中间产物是图片的压缩版本，训练：\n（2）中间产物是latent representation，训练auto-encoder：\nGeneration Model 将图片输入encoder，得到latent representation，对latent representation进行加噪和去噪操作进行训练，预测过程不变。（因为输出变成了一个latent representation）\n2. Details 2.1 Training Algorithm（训练过程） 抽取clean image，原始图片\n抽取一个时间步t\n随机取样noise\n计算梯度：原始图片和noise以一个权重（事先定义）相加，经过predicter预测一个noise，与原noise做平方差，求导得梯度。\n数学推导：\n$$x_{0}到x_{t}可以简化为如下公式，因此可以把beta式简化为alpha_{t},alpha_{t}由大变小$$\n2.2 Sampling Algorithm（生成过程） 公式推导（已知）：\u0026ndash;基于最大似然估计\n已知噪声预测$q(x_{t-1}|x_{t},x_0)$的分布（其实就是 $x_{t-1}$的分布），而predicter预测结果 $P(x_{t-1}|x_{t})$的分布要与噪声预测 $q(x_{t-1}|x_{t},x_0)$分布越接近越好，在不考虑方差的情况下，那就是使得predicter预测的均值与噪声预测分布的均值越接近越好。\n噪声预测均值为:\n即predicter预测分布的均值，再加上随机噪声z和固定方差 $\\sigma$( $\\sigma_t^2通常取\\beta_t$)，得到预测分布。\n补充：在得到 $x_0$（利用预测噪声）和 $x_t$之后，可以利用后验概率计算得到 $x_{t-1}$(在数学上和上述式子是等价的):\n$$\\hat{x}_0 = \\frac{1}{\\sqrt{\\bar{\\alpha}_t}}(x_t - \\sqrt{1-\\bar{\\alpha}_t} \\epsilon_\\theta)$$$$\\tilde{mu}_t = \\frac{\\sqrt{\\bar{\\alpha}_{t-1}}\\beta_t}{1-\\bar{\\alpha}_t}x_0 + \\frac{\\sqrt{\\alpha_t}(1-\\bar{\\alpha}_{t-1})}{1-\\bar{\\alpha}_t}x_t$$\n3. Improved DDPM 虽然 DDPM 在生成任务上取得了不错的效果，但如果使用一些 metric 对 DDPM 进行评价，就会发现其虽然能在 FID 和 Inception Score 上获得不错的效果，但在负对数似然（Negative Log-likelihood，NLL）这个指标上表现不够好。\nNLL 上的表现体现的是模型捕捉数据整体分布的能力。而且有工作表明即使在 NLL 指标上仅有微小的提升，就会在生成效果和特征表征能力上有很大的提升。\nImproved DDPM 主要是针对 DDPM 的训练过程进行改进，主要从两个方面进行改进：\n1.不使用 DDPM 原有的固定方差，而是使用可学习的方差；\n这个工作的作者认为因为方差的变化范围比较小，不太容易用神经网络进行学习，所以实际上使用的方差是对 $\\beta_t$和 $\\tilde{\\beta_t}$ 进行插值的结果（log形式，v是一个可学习的参数（0-1））， $\\beta_t$是方差最大值， $$\\tilde{\\beta}_t = \\frac{1-\\bar{\\alpha}_{t-1}}{1-\\bar{\\alpha}_t} \\beta_t $$ 是最小值\n2.改进了加噪过程，使用余弦形式的 Scheduler，而不是线性 Scheduler。\n本文的作者发现线性的 $\\beta_t$对于高分辨率图像效果不错，但对于低分辨率的图像表现不佳。因为如果最开始的时候加入很大的噪声，会严重破坏图像信息，不利于图像的学习。\n作者把方差用一种 cosine 的形式定义，不过并不是直接定义 $\\beta_t$，而是定义 $\\bar{\\alpha_t}$。\n变化差异如图所示。\n训练过程和代码实现详见：https://littlenyima.github.io/posts/15-improved-denoising-diffusion-probabilistic-models/\n3.重要性采样\n在计算损失函数时，损失函数包括DDPM的L2损失和VLB损失两项。其中VLB损失为1-T的所有时间步的加和平均。\n但这会带来两个问题：\n1.计算量大： 需要计算所有 T 个时间步的损失。\n2.方差高： 不同时间步 t 的 $L_t$ 项对方差的贡献可能非常不均匀。\n为了解决这两个问题，Improved Diffusion 模型提出了一种采样时间步 t 的方法来估计 VLB 损失，具体为对每个时间步存储最近的10个历史损失，根据每个时间步的损失大小分配权重w，并且对w进行动态更新（EMA？）\n实际操作：\n1.采样 t： 模型从重要性采样分布 p(t) 中采样一个时间步 t\n2.计算 $L_t$： 计算在当前采样的 t 上的 VLB 损失项 $$L_t = D_{\\text{KL}}(q(\\mathbf{x}_{t-1}|\\mathbf{x}_t, \\mathbf{x}_0) || p_\\theta(\\mathbf{x}_{t-1}|\\mathbf{x}_t))$$3.应用权重： 将 $L_t$ 乘以重要性校正权重 $W_t = frac{1/T}{p(t)}$，得到该迭代的 VLB 估计损失： $$\\hat{L}_{\\text{VLB}} = W_t \\cdot L_t$$最终的训练损失是这两个损失的加权和：\n$$\\mathcal{L}_{\\text{total}} = \\mathcal{L}_{\\text{simple}} + \\lambda \\cdot \\mathcal{L}_{\\text{VLB}}$$其中 $\\lambda$ 是 VLB 损失的权重，通常是一个较小的常数。\n优化 VLB 损失直接强制模型学习一个更准确的噪声概率分布 $p_\\theta(\\mathbf{x}_0)$（因为VLB损失使得模型预测方差更接近真实的方差）。这使得模型能够更好地泛化到训练集之外的数据\n为了计算简单，加快优化，对 VLB 损失中的均值项进行了 stop-gradient，从而让 $\\mathcal{L}_{\\text{simple}}$依然是均值的主要决定因素。\nIDDPM 的训练使用了两个主要目标：\n1.$\\mathcal{L}_{\\text{simple}}$： 主要负责优化 去噪均值（即 $\\mathbf{\\epsilon}_\\theta$）。\n2.$\\mathcal{L}_{\\text{VLB}}$： 主要负责优化 反向过程的方差 $$\\mathbf{\\Sigma}_\\theta$$（因为均值部分已经被 $\\mathcal{L}_{\\text{simple}}$ 充分优化）。\nKL散度计算（注意，模型预测的方差实际上是方差的log形式）：\n4. Classifier Free Guidance 通过加入condition，来引导生成的图像朝着我们想要的方向进行。\n中间计算过程不再推导，基于Classifier Guidance实现\n如下所示。两项分别是无条件生成的分数以及从无条件生成指向有条件生成的方向，这样看就更清晰了：classifier-free guidance 就是从无条件生成的基础上向某个条件的方向移动， s是一个用来控制条件重要性的参数。\n可以通过分别对无条件生成和有条件生成进行学习，得到无需分类器的有条件生成模型。(无条件生成是有条件生成的基础，生成的质量和多样性是由无条件生成的分数保证的，如果只有有条件生成而没有无条件生成，那么生成效果可能不佳。)\n为了联合训练有条件和无条件的情况，在训练时需要以一定的概率p 将条件输入替换为空 。\n文中也给出了采样算法的流程，可以看到预测噪声由无条件和有条件两部分加权得到：\n条件注入的方法 我们知道去噪模型通常使用的都是 UNet，将条件注入 UNet 有几种比较常见的方式，即交叉注意力、通道注意力以及自适应归一化等。\n1.Cross Attention *\n交叉注意力是比较常用的一种条件注入方式，在注入时是以 x 为 query、以 condition 为 key 和 value。\nhttps://zhuanlan.zhihu.com/p/1970452052778919816\n2.Channel-wise Attention *\n通道注意力相对比较简单。虽然叫注意力，但其实就是做完 projection 直接加到 time embedding 上。\nhttps://www.cnblogs.com/medcs/p/18926383\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class TimestepEmbedding(nn.Module): ... def forward(self, sample, condition=None): if condition is not None: # 条件在这里注入 sample = sample + self.cond_proj(condition) sample = self.linear_1(sample) if self.act is not None: sample = self.act(sample) sample = self.linear_2(sample) if self.post_act is not None: sample = self.post_act(sample) return sample 上述代码中的 cond_proj 的定义如下，可以看到就是一个 linear 层：\n1 self.cond_proj = nn.Linear(cond_proj_dim, in_channels, bias=False) ","date":"2026-01-08T18:39:21+08:00","image":"https://lilzee123.github.io/AMS_Blog/p/diffusion/Haruka_hu_6b40874dc1eb308c.png","permalink":"https://lilzee123.github.io/AMS_Blog/p/diffusion/","title":"Diffusion"}]